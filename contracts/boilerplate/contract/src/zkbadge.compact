pragma language_version >= 0.14.0;

import CompactStandardLibrary;

export { Maybe };
export { CoinInfo };
export { ZswapCoinPublicKey };
export { Certificate };

export enum STATUS { Pending, Verified };

struct Certificate {
  subject: Opaque<"string">,
  issuer: ZswapCoinPublicKey,
  issued_at: Uint<64>,
  valid_until: Uint<64>,
  is_valid: Boolean,
  owner: ZswapCoinPublicKey
}

witness user_certificate(): Certificate;

export sealed ledger admin: ZswapCoinPublicKey;
export ledger registered_hashes: Map<Bytes<32>, STATUS>;

export ledger verified_users: Map<ZswapCoinPublicKey, Boolean>;

constructor() {
    admin = own_public_key();
}

// Admin verifies valid certificate hashes off-chain
export circuit verify_certificates(hashes: Vector<10, Maybe<Bytes<32>>>): [] {
  assert (own_public_key() == admin) "Not admin";
  for (const maybe_hash of hashes) {
    if (maybe_hash.is_some) {
      registered_hashes.insert(maybe_hash.value, STATUS.Verified);
    }
  }
}

// User registers their certificate privately
export circuit register(): [] {
  const cert = disclose(user_certificate());

  assert (cert.is_valid == true) "Certificate not valid";
  assert (cert.valid_until > now()) "Certificate expired";
  assert (cert.owner == own_public_key()) "Not your certificate";

  const hash = cert_hash(cert);
  registered_hashes.insert(hash, STATUS.Pending);
}

// Anyone can check if a user's cert is verified
export circuit check_verification(): Boolean {
  const cert = disclose(user_certificate());
  const hash = cert_hash(cert);
  return registered_hashes.lookup(hash) == STATUS.Verified;
}

// Allow gated feature to verified users
export circuit access_private_feature(): [] {
  const cert = disclose(user_certificate());
  const hash = cert_hash(cert);
  assert registered_hashes.lookup(hash) == STATUS.Verified "Access denied";
  verified_users.insert(cert.owner, true);
}

// Hashing function
export circuit cert_hash(cert: Certificate): Bytes<32> {
  return persistent_hash<Certificate>(cert);
}
